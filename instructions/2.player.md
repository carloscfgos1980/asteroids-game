# 1. Modules

It would be a massive pain if we had to fit all of our code into a single file.

Importing
In Python, each .py file is a module, and we can import functions, variables, and classes from one module into another with the import statement. The name of a module is the filename (without the .py extension).

# import the connect_database function

# and the database_version variable

# from database.py into the current file

from database import connect_database, database_version

If you want to import everything from a module, you can use the * character:

# import everything from the module

# database.py into the current file

from database import *

However, it's generally recommended to avoid wildcard imports (*) as they make your code harder to read and debug. You can read more about this in the Python style guide.

Constants
Games often have a lot of magic numbers to represent things like player speeds, item costs, and attack damage. We will use this file as a place to store those kind of constant values.

Assignment
Create a new file in your project called constants.py (in the same folder as main.py), and paste this in:
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720

ASTEROID_MIN_RADIUS = 20
ASTEROID_KINDS = 3
ASTEROID_SPAWN_RATE = 0.8  # seconds
ASTEROID_MAX_RADIUS = ASTEROID_MIN_RADIUS * ASTEROID_KINDS

Import everything from the constants.py file into main.py
Print out the SCREEN_WIDTH and SCREEN_HEIGHT values when main.py is run. Use the following format:
Along with a greeting from importing pygame, the expected output is the following:

Starting Asteroids!
Screen width: 1280
Screen height: 720

# 2. Game Loop

Video games are generally built using a game loop. The simplest game loop has 3 steps:

Check for player inputs
Update the game world
Draw the game to the screen
To create a good user experience, these 3 steps need to happen many times per second.

Assignment
import pygame at the top of your main.py file. The pygame documentation will be super useful throughout this project.
Initialize pygame at the beginning of your main() function (take a look at the docs for the syntax).
Ensure our predefined constants (constants.py) SCREEN_WIDTH and SCREEN_HEIGHT are imported at the top of your file:
from constants import *

Because this is a smaller project, and we don't risk conflicting import names, we're going to use a wildcard import for convenience. In a larger project, you'd want to import only the constants you need.
Use pygame's display.set_mode() to get a new GUI window:
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

Create the game loop. For now, we'll only worry about step 3: drawing the game onto the screen.
Use an infinite while loop for the game loop. At each iteration, it should:
Use the screen's fill method to fill the screen with a solid "black" color.
Use pygame's display.flip() method to refresh the screen. Be sure to call this last!
It's a good idea to run and test your game frequently as you write code , to make sure it's working as expected:
If you're on a mac, wait until step 8 before doing this.
uv run main.py

You should see a black window open and stay open.

Close the game and kill the program with Ctrl+C in the terminal.
Add the following code to the beginning of each iteration of the game loop:
for event in pygame.event.get():
    if event.type == pygame.QUIT:
        return

This will check if the user has closed the window and exit the game loop if they do. It will make the window's close button work.

Make a git commit! It's a good idea to commit your progress whenever you get something new working.


# 3. FPS

Right now, our game is re-drawing the screen as fast as it possibly can. This causes it to use a lot more CPU than it actually needs!

Delta Time
In math, the Greek letter delta (Î”) is often used to represent a change in a value. In game development, we use "delta time" to represent the amount of time that has passed since the last frame was drawn. This value is useful to decouple the game's speed from the speed it's being drawn to the screen.

If your computer speeds up, the asteroids shouldn't also speed up. Conversely, if your computer slows down, the asteroids shouldn't also slow down: they would just move less smoothly.

Assignment
FPS stands for frames per second. We're going to restrict our game to draw a maximum of 60 times per second, or 60 FPS.

After initializing pygame, but before the gameloop starts, create:
A new clock object using pygame.time.Clock.
A dt variable set to 0.
At the end of each iteration of the game loop, call the .tick() method on the clock object, and pass it 60. It will pause the game loop until 1/60th of a second has passed.
The .tick() method also returns the amount of time that has passed since the last time it was called: the delta time. Divide the return value by 1000 (to convert from milliseconds to seconds) and save it into the dt variable we created earlier. We're not using dt yet, but we will later.
Re-run the game. You should still see the same black screen, but this time it should use less of your system's resources!

# 4. Sprites

Throughout this project, we will provide some of the code for you, like the class below. We want you to focus on specific parts and have pre-written the stuff that isn't related to the concepts we're trying to teach.
In pygame, there is a base class called Sprite, to represent visual objects.

Assignment
In our game, asteroids are visually represented as circles, and the player is a triangle. However, detecting collisions between circles and triangles is hard. To avoid this problem, we can cheat a little bit: the player will secretly be a circle.

The red circle won't be visible in the game; only we need to know it exists.

Let's create a CircleShape class that inherits from Sprite to represent objects in our game that are treated as circles (even if they aren't).

Create a new circleshape.py file and paste in the following code:

import pygame

<# Base class for game objects>

class CircleShape(pygame.sprite.Sprite):
    def __init__(self, x, y, radius):
        # we will be using this later
        if hasattr(self, "containers"):
            super().__init__(self.containers)
        else:
            super().__init__()

        self.position = pygame.Vector2(x, y)
        self.velocity = pygame.Vector2(0, 0)
        self.radius = radius

    def draw(self, screen):
        # sub-classes must override
        pass

    def update(self, dt):
        # sub-classes must override
        pass

CircleShape extends the Sprite class to also store a position, velocity, and radius.

Later you'll write subclasses of CircleShape and override the draw and update methods with the logic for that particular game object.

Run and submit the CLI tests from the root of the project.

# 5. Draw Player

Let's draw a spaceship for the player!

Assignment
Add this line to constants.py to define the size of the player's ship:
PLAYER_RADIUS = 20

Create a new file called player.py with a Player class that inherits from CircleShape.
The Player constructor should take x and y integers as input, then:
Call the parent class's constructor, also passing in PLAYER_RADIUS
Create a field called rotation, initialized to 0
Paste this triangle method into your Player class:

# in the player class

def triangle(self):
    forward = pygame.Vector2(0, 1).rotate(self.rotation)
    right = pygame.Vector2(0, 1).rotate(self.rotation + 90) *self.radius / 1.5
    a = self.position + forward* self.radius
    b = self.position - forward *self.radius - right
    c = self.position - forward* self.radius + right
    return [a, b, c]

A player will look like a triangle, even though we'll use a circle to represent its hitbox. The math of drawing a triangle can be a bit fiddly, so we've written the method for you.

To draw the player, override the draw method of CircleShape. It should take the screen object as a parameter, and call pygame.draw.polygon. It takes:
The screen object
A color (use "white")
A list of points (use self.triangle() that we provided for you)
A line width (use 2)
In your main function, instantiate a Player object. You can pass these values to the constructor to spawn it in the middle of the screen:
x = SCREEN_WIDTH / 2
y = SCREEN_HEIGHT / 2
Lastly, we need to re-render the player on the screen each frame, meaning inside our game loop. Use the player.draw(screen) method we just added to do so.
Draw the player after filling the screen with black, but before flipping the screen.
Run the game. If everything worked, you should see a black screen with a white triangle in the middle. Progress!

# 6. Moving Around

We want the spaceship to be able to move; but what does that mean specifically? Let's break it down:

If we press the move-left key, the ship should rotate to the left.
If we press the move-right key, the ship should rotate to the right.
If we press the move-forward key, the ship should move forward.
If we press the move-backward key, the ship should move backward.
Left and right seem pretty similar. Let's try to write a small function to tackle those first!

Assignment
Create a new constant in constants.py to represent the player's turn speed. I named mine PLAYER_TURN_SPEED, and gave it a value of 300.
Add a new method to the Player class called rotate. It's going to take one argument: dt (I told you we'd use it!). When it's called, it should add PLAYER_TURN_SPEED * dt to the player's current rotation.
Paste in the following update method to the Player class:
    def update(self, dt):
        keys = pygame.key.get_pressed()

        if keys[pygame.K_a]:
            # ?
        if keys[pygame.K_d]:
            # ?

If you're using a non-QWERTY keyboard, you may want to change the keybindings in the code to something other than the W, A, S and D keys.
Update the missing lines to call the rotate method with the dt argument. To go left instead of right when a is pressed, you'll need to reverse dt... how can you do that...?
Hook the update method into the game loop by calling it on the player object each frame before rendering.

# 7. Moving

Now instead of rotating, we need the ship to move back and forth with the W and S keys.

Assignment
Create a new constant in constants.py to represent the player speed. I named mine PLAYER_SPEED, and gave it a value of 200.
Add a new method to the Player class called .move(). It takes one argument: dt. We want to modify the player's position; but first, we need to do a little bit of math.
We start with a unit vector pointing straight up from (0, 0) to (0, 1).
We rotate that vector by the player's rotation, so it's pointing in the direction the player is facing.
We multiply by PLAYER_SPEED * dt. A larger vector means faster movement.
Add the vector to our position to move the player.

This is a course on programming, not vector math, so we've done the math for you. All those words boil down to these two lines of code:

forward = pygame.Vector2(0, 1).rotate(self.rotation)
self.position += forward *PLAYER_SPEED* dt

Modify the update method in the Player class to call the move method when the W or S keys are pressed.


# 8. Groups

Currently, we manually call .update() and .draw() on the player object, which means our game loop is going to get more and more cluttered as we add additional objects to the game. Fortunately, pygame has a solution!

The Group class is a container that holds and manages multiple game objects. We can organize our objects into various groups to track them more easily.

You can think of them as a sort of Venn diagram. An object can be in multiple groups at the same time! Eventually, our game's groups will look something like this:

Creating and Using Groups
You can create a new empty group like this:

my_group = pygame.sprite.Group()

To add all instances of a Player to two groups, group_a and group_b in this example, we add a class variable (or static field) called containers to the class just like so (with literally this one line, you don't need to bother with adding this field to the class declaration):

Player.containers = (group_a, group_b)

After changing a static field like containers, make sure to create all Player objects after the change. This way, they will be correctly added to the groups.
You can iterate over objects in a group just like any other collection in Python:

for thing in group:
    thing.do_something(some_value)

You may also call the .update() method for every member of a group by calling it on the group itself:

group.update(dt)

Assignment
Before the game loop starts:

Create two groups in main.py:
updatable - all the objects that can be updated
drawable - all the objects that can be drawn
Set both groups as containers for the Player.
Change the game loop to use the new groups instead of the Player object directly.
Call the .update() method on the "updatables" group.
Loop over all "drawables" and .draw() them individually.
